---
import { readdir, readFile } from "node:fs/promises";
import { join } from "node:path";
import matter from "gray-matter";
import { marked } from "marked";
import BaseLayout from "../../layouts/BaseLayout.astro";

export async function getStaticPaths() {
  const toolsDir = join(process.cwd(), "content", "tools");
  const files = (await readdir(toolsDir)).filter(
    (f) => f.endsWith(".md") && !f.startsWith("_")
  );
  return files.map((file) => ({ params: { slug: file.replace(/\.md$/, "") } }));
}

function normalizeTags(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.map(String).map((s) => s.trim()).filter(Boolean);
  if (typeof value === "string") return value.split(",").map((s) => s.trim()).filter(Boolean);
  return [];
}

/**
 * FAQ -> <details>/<summary>
 * Supports:
 *  - ## FAQ + ### Question
 *  - ## FAQ + **Question** paragraphs (your current format)
 */
function faqToAccordion(inputHtml) {
  const reSection = /<h2[^>]*>\s*FAQ\s*<\/h2>([\s\S]*?)(?=<h2[^>]*>|$)/i;
  const m = inputHtml.match(reSection);
  if (!m) return { html: inputHtml, hasFaq: false };

  const sectionBody = m[1];

  // Helper to build accordion HTML
  const buildAccordion = (items) => {
    const out = items
      .map(({ q, a }) => {
        const qq = (q || "").trim();
        const aa = (a || "").trim();
        if (!qq || !aa) return null;
        return `<details>
  <summary>${qq}</summary>
  <div class="answer">${aa}</div>
</details>`;
      })
      .filter(Boolean);

    if (!out.length) return null;
    return `<section class="faq"><h2>FAQ</h2>${out.join("")}</section>`;
  };

  // A) Format with <h3>
  if (/<h3\b/i.test(sectionBody)) {
    const parts = sectionBody.split(/<h3[^>]*>/i);
    const items = [];
    for (let i = 1; i < parts.length; i++) {
      const chunk = parts[i];
      const endTitle = chunk.search(/<\/h3>/i);
      if (endTitle === -1) continue;
      const q = chunk.slice(0, endTitle).replace(/<[^>]+>/g, "").trim();
      const a = chunk.slice(endTitle).replace(/<\/h3>/i, "").trim();
      items.push({ q, a });
    }
    const accordion = buildAccordion(items);
    if (accordion) return { html: inputHtml.replace(reSection, accordion), hasFaq: true };
  }

  // B) Format with <p><strong>Question</strong></p>
  // Find all questions inside the FAQ section and capture their answers until next question
  const qRe = /<p>\s*<strong>([\s\S]*?)<\/strong>\s*<\/p>/gi;
  const matches = [];
  let q;
  while ((q = qRe.exec(sectionBody)) !== null) {
    matches.push({ idx: q.index, len: q[0].length, q: q[1] });
  }
  if (!matches.length) return { html: inputHtml, hasFaq: false };

  const items = [];
  for (let i = 0; i < matches.length; i++) {
    const cur = matches[i];
    const next = matches[i + 1];
    const start = cur.idx + cur.len;
    const end = next ? next.idx : sectionBody.length;
    const qText = String(cur.q).replace(/<[^>]+>/g, "").trim();
    const aHtml = sectionBody.slice(start, end).trim();
    items.push({ q: qText, a: aHtml });
  }

  const accordion = buildAccordion(items);
  if (!accordion) return { html: inputHtml, hasFaq: false };

  return { html: inputHtml.replace(reSection, accordion), hasFaq: true };
}

const { slug } = Astro.params;

const filePath = join(process.cwd(), "content", "tools", `${slug}.md`);
const raw = await readFile(filePath, "utf-8");
const { data, content } = matter(raw);

const title = String(data.title ?? slug);
const category = data.category ? String(data.category) : "";
const price_model = data.price_model ? String(data.price_model) : "";
const tags = normalizeTags(data.tags);

const heroImage = data.image ? String(data.image) : "";

// if markdown already has an image, don't show hero image
const mdHasImage = /!\[[^\]]*\]\([^)]+\)/.test(content) || /<img\s/i.test(content);

let html = String(marked.parse(content));

// remove first H1 to avoid duplicate title
html = html.replace(/<h1[^>]*>[\s\S]*?<\/h1>\s*/i, "");

// FAQ -> accordion
const faqRes = faqToAccordion(html);
html = faqRes.html;

// if resulting html contains <img>, also don't show hero
const htmlHasImage = /<img\s/i.test(html);
const showHero = Boolean(heroImage) && !mdHasImage && !htmlHasImage;

// aside only when we actually show hero image (FAQ stays inside article)
const showAside = showHero;
---

<BaseLayout title={`${title} — utildesk`} description={(data.description ? String(data.description) : "")}>
  <p class="breadcrumb"><a href="/tools/">← Tools</a></p>

  <h1>{title}</h1>

  {(category || price_model) ? (
    <div class="pills" aria-label="Meta" style="margin-top:10px;">
      {category ? <span class="pill"><strong>Category</strong> {category}</span> : null}
      {price_model ? <span class="pill"><strong>Preis</strong> {price_model}</span> : null}
    </div>
  ) : null}

  {tags.length ? (
    <div class="pills" aria-label="Tags" style="margin-top:10px;">
      {tags.map((t) => <span class="pill pill--tag">{t}</span>)}
    </div>
  ) : null}

  <div class={`tool-hero ${showAside ? "" : "tool-hero--single"}`}>
    <article class="article" set:html={html}></article>

    {showAside ? (
      <aside class="aside">
        <div class="aside-card">
          <img class="aside-thumb" src={heroImage} alt={title} loading="lazy" />
          <div class="aside-body">
            <div class="pills" aria-label="Meta">
              {category ? <span class="pill"><strong>Category</strong> {category}</span> : null}
              {price_model ? <span class="pill"><strong>Preis</strong> {price_model}</span> : null}
            </div>
          </div>
        </div>
      </aside>
    ) : null}
  </div>
</BaseLayout>
