---
import { readdir, readFile } from "node:fs/promises";
import { join } from "node:path";
import matter from "gray-matter";
import { marked } from "marked";
import BaseLayout from "../../layouts/BaseLayout.astro";

export async function getStaticPaths() {
  const toolsDir = join(process.cwd(), "content", "tools");
  const files = (await readdir(toolsDir)).filter(
    (f) => f.endsWith(".md") && !f.startsWith("_")
  );

  return files.map((file) => ({ params: { slug: file.replace(/\.md$/, "") } }));
}

function normalizeTags(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.map(String).map((s) => s.trim()).filter(Boolean);
  if (typeof value === "string") return value.split(",").map((s) => s.trim()).filter(Boolean);
  return [];
}

/**
 * Convert a FAQ section inside HTML to <details>/<summary>.
 * Supports 2 formats:
 *  A) <h2>FAQ</h2> + repeated <h3>Question</h3> ...answer...
 *  B) <h2>FAQ</h2> + repeated <p><strong>Question</strong></p> ...answer...
 */
function faqToAccordion(inputHtml) {
  const reSection = /<h2[^>]*>\s*FAQ\s*<\/h2>([\s\S]*?)(?=<h2[^>]*>|$)/i;
  const m = inputHtml.match(reSection);
  if (!m) return { html: inputHtml, hasFaq: false };

  const sectionBody = m[1];

  // --- Helper: build <details> items from pairs ---
  const build = (pairs) => {
    const items = pairs
      .map(({ q, a }) => {
        const qq = (q || "").trim();
        const aa = (a || "").trim();
        if (!qq || !aa) return null;
        return `<details>
  <summary>${qq}</summary>
  <div class="answer">${aa}</div>
</details>`;
      })
      .filter(Boolean);

    if (!items.length) return null;

    return `<section class="faq"><h2>FAQ</h2>${items.join("")}</section>`;
  };

  // --- Format A: split by <h3> ---
  if (/<h3\b/i.test(sectionBody)) {
    const parts = sectionBody.split(/<h3[^>]*>/i);
    if (parts.length >= 2) {
      const pairs = [];
      for (let i = 1; i < parts.length; i++) {
        const chunk = parts[i];
        const endTitle = chunk.search(/<\/h3>/i);
        if (endTitle === -1) continue;

        const q = chunk.slice(0, endTitle).replace(/<[^>]+>/g, "").trim();
        const a = chunk.slice(endTitle).replace(/<\/h3>/i, "").trim();
        pairs.push({ q, a });
      }
      const accordion = build(pairs);
      if (accordion) {
        return { html: inputHtml.replace(reSection, accordion), hasFaq: true };
      }
    }
  }

  // --- Format B: <p><strong>Question</strong></p> blocks ---
  // Split on <p><strong> ... </strong></p>
  const blocks = sectionBody.split(/<p>\s*<strong>/i);
  if (blocks.length >= 2) {
    const pairs = [];
    for (let i = 1; i < blocks.length; i++) {
      const chunk = blocks[i];
      const endStrongP = chunk.search(/<\/strong>\s*<\/p>/i);
      if (endStrongP === -1) continue;

      const qRaw = chunk.slice(0, endStrongP);
      const q = qRaw.replace(/<[^>]+>/g, "").trim();

      // Answer = remainder after </strong></p> until next question block (which is next split)
      const a = chunk.slice(endStrongP).replace(/<\/strong>\s*<\/p>/i, "").trim();

      // Clean: if answer accidentally starts with <p> etc it's fine (we keep html)
      pairs.push({ q, a });
    }

    const accordion = build(pairs);
    if (accordion) {
      return { html: inputHtml.replace(reSection, accordion), hasFaq: true };
    }
  }

  return { html: inputHtml, hasFaq: false };
}

const { slug } = Astro.params;

const filePath = join(process.cwd(), "content", "tools", `${slug}.md`);
const raw = await readFile(filePath, "utf-8");
const { data, content } = matter(raw);

const title = String(data.title ?? slug);
const category = data.category ? String(data.category) : "";
const price_model = data.price_model ? String(data.price_model) : "";
const tags = normalizeTags(data.tags);

const heroImage = data.image ? String(data.image) : "";

// if markdown already has an image, don't show hero image
const mdHasImage = /!\[[^\]]*\]\([^)]+\)/.test(content) || /<img\s/i.test(content);

let html = String(marked.parse(content));

// remove first H1 to avoid duplicate title
html = html.replace(/<h1[^>]*>[\s\S]*?<\/h1>\s*/i, "");

// FAQ -> accordion
const faqRes = faqToAccordion(html);
html = faqRes.html;

// if resulting html contains <img>, also don't show hero
const htmlHasImage = /<img\s/i.test(html);
const showHero = Boolean(heroImage) && !mdHasImage && !htmlHasImage;

const showAside = showHero; // aside only for image/meta (FAQ stays inside article)
---

<BaseLayout title={`${title} — utildesk`} description={(data.description ? String(data.description) : "")}>
  <p class="breadcrumb"><a href="/tools/">← Tools</a></p>

  <h1>{title}</h1>

  {(category || price_model) ? (
    <div class="pills" aria-label="Meta" style="margin-top:10px;">
      {category ? <span class="pill"><strong>Category</strong> {category}</span> : null}
      {price_model ? <span class="pill"><strong>Preis</strong> {price_model}</span> : null}
    </div>
  ) : null}

  {tags.length ? (
    <div class="pills" aria-label="Tags" style="margin-top:10px;">
      {tags.map((t) => <span class="pill pill--tag">{t}</span>)}
    </div>
  ) : null}

  <div class="tool-hero">
    <article class="article" set:html={html}></article>

    {showAside ? (
      <aside class="aside">
        {showHero ? (
          <div class="aside-card">
            <img class="aside-thumb" src={heroImage} alt={title} loading="lazy" />
            <div class="aside-body">
              <div class="pills" aria-label="Meta">
                {category ? <span class="pill"><strong>Category</strong> {category}</span> : null}
                {price_model ? <span class="pill"><strong>Preis</strong> {price_model}</span> : null}
              </div>
            </div>
          </div>
        ) : null}
      </aside>
    ) : null}
  </div>
</BaseLayout>
